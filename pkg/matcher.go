package pkg

import (
	"context"
	"fmt"
	"strconv"

	"github.com/go-logr/logr"
	tlogr "github.com/go-logr/logr/testing"
	gerr "github.com/pkg/errors"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

func checkExpectation(clt client.Client, ep Expectation) error {
	fn := MatcherRouter(ep.Matcher)
	if fn == nil {
		return gerr.New(fmt.Sprintf("expectation %v failed to find a matcher", ep))
	}

	t := tlogr.TestLogger{}
	return fn.Match(clt, ep, t)
}

type Arg string

//type Match func(client.Client, Expect, Arg) bool

type Matcher interface {
	Match(client.Client, Expectation, logr.Logger) error
}

func MatcherRouter(name string) Matcher {
	switch name {
	case "byname":
		return ByName{}
	case "byannotation":
		return ByAnnotation{}
	case "byannotationcount":
		return ByAnnotationCount{}
	case "bylabel":
		return ByLabel{}
	case "bygeneration":
		return ByGeneration{}
	default:
		return nil
	}
}

type ByName struct{}

func (b ByName) Match(clt client.Client, ep Expectation, logger logr.Logger) error {
	ins := ep.GetInstance()
	key := ep.GetKey()

	if err := clt.Get(context.TODO(), key, ins); err != nil {
		return gerr.Wrapf(err, "failed to get instance %s/%s of kind %s", ep.Namespace, ep.Name, ep.Kind)
	}

	logger.Info(fmt.Sprintf("found %s of kind %s", key.String(), ep.Kind))
	return nil
}

type ByAnnotation struct{}

// Basiclly, list all the instance and check if there's instance generated by
// subscription
func (b ByAnnotation) Match(clt client.Client, ep Expectation, logger logr.Logger) error {
	if len(ep.Args) == 0 {
		return gerr.New("using the byannotation matcher, but NO annotation key:val is provided in the Args field")
	}

	ins := ep.GetInstance()
	key := ep.GetKey()

	if err := clt.Get(context.TODO(), key, ins); err != nil {
		return gerr.Wrapf(err, "failed to get instance %s of kind %s", key.String(), ep.Kind)
	}

	an := ins.GetAnnotations()

	for k, v := range ep.Args {
		if cv, ok := an[k]; !ok || v != cv {
			return fmt.Errorf("kind %s of %s has cluster annotation %s,  is not matching expectation %s", ep.Kind, key.String(), cv, v)
		}
	}

	logger.Info(fmt.Sprintf("found kind %s of %s which matched annotation %+v", ep.Kind, key.String(), ep.Args))
	return nil
}

type ByAnnotationCount struct{}

func (b ByAnnotationCount) Match(clt client.Client, ep Expectation, logger logr.Logger) error {
	if len(ep.Args) == 0 {
		return gerr.New("using the byannotationcount matcher, but NO annotation key:val is provided in the Args field")
	}

	cnt, ok := ep.Args["count"]
	if !ok {
		return gerr.New(fmt.Sprintf("%s, using the byannotationcount matcher, but NO count:val is provided in the Args field", ep.Desc))
	}

	icnt, err := strconv.Atoi(cnt)
	if err != nil {
		return gerr.New("can't parse the count filed to int")
	}

	insList := ep.GetInstanceList()
	key := ep.GetKey()

	if err := clt.List(context.TODO(), insList, &client.ListOptions{Namespace: ep.Namespace}); err != nil {
		return gerr.Wrapf(err, "failed to get instanceList %s of kind %s", key.String(), ep.Kind)
	}

	logger.Info(fmt.Sprintf("got ins %v, details %#v\n", len(insList.Items), insList.Items))

	c := 0
	for _, item := range insList.Items {
		if contains(ep.Args, item.GetAnnotations(), "count") {
			c += 1
		}
	}

	logger.Info(fmt.Sprintf("found kind %s of %s which matched annotation %+v", ep.Kind, key.String(), ep.Args))

	if icnt != c {
		return gerr.New(fmt.Sprintf("expecting kind %s has %d item(s), cluster has %d item(s)", ep.Kind, icnt, c))
	}

	return nil
}

type ByLabel struct{}

func (b ByLabel) Match(clt client.Client, ep Expectation, logger logr.Logger) error {
	if len(ep.Args) == 0 {
		return gerr.New("using the bylabel matcher, but NO label key:val is provided in the Args field")
	}

	ins := ep.GetInstance()
	key := ep.GetKey()

	if err := clt.Get(context.TODO(), key, ins); err != nil {
		return gerr.Wrapf(err, "failed to get instance %s of kind %s", key.String(), ep.Kind)
	}

	labels := ins.GetLabels()

	for k, v := range ep.Args {
		if cv, ok := labels[k]; !ok || v != cv {
			return fmt.Errorf("kind %s of %s has label %s,  is not matching expectation %s", ep.Kind, key.String(), cv, v)
		}
	}

	logger.Info(fmt.Sprintf("found kind %s of %s which matched label %+v", ep.Kind, key.String(), ep.Args))
	return nil
}

type ByGeneration struct{}

func (b ByGeneration) Match(clt client.Client, ep Expectation, logger logr.Logger) error {
	if len(ep.Args) == 0 {
		return gerr.New("using the bylabel matcher, but NO label key:val is provided in the Args field")
	}

	ins := ep.GetInstance()
	key := ep.GetKey()

	if err := clt.Get(context.TODO(), key, ins); err != nil {
		return gerr.Wrapf(err, "failed to get instance %s of kind %s", key.String(), ep.Kind)
	}

	generation := ins.GetGeneration()

	v, ok := ep.Args["generation"]
	if !ok {
		return fmt.Errorf("generation is not definced in expectation args")
	}
	cv, err := strconv.ParseInt(v, 10, 64)
	if err != nil {
		return gerr.New("can't parse the generation filed to int64")
	}
	if cv != generation {
		return fmt.Errorf("kind %s of %s has generation is not matching expectation %s", ep.Kind, key.String(), v)
	}

	logger.Info(fmt.Sprintf("found kind %s of %s which matched generation", ep.Kind, key.String()))
	return nil
}

func contains(small, big map[string]string, skip string) bool {
	for k, v := range small {
		if k == skip {
			continue
		}

		if bv, ok := big[k]; !ok || v != bv {
			return false
		}
	}

	return true
}
